# Урок 7: Docker Compose для многоконтейнерных приложений

## Введение в Docker Compose

**Docker Compose** — это мощный инструмент, упрощающий управление многоконтейнерными приложениями Docker. Он позволяет определять и запускать несколько контейнеров как одну службу с помощью простого файла конфигурации YAML. С Docker Compose вы можете легко организовать развертывание приложений, состоящих из нескольких служб, таких как веб-серверы, базы данных и системы кэширования.

### Преимущества использования Docker Compose

1. **Упрощенная конфигурация**: Docker Compose использует один файл `docker-compose.yml` для определения всех служб, сетей и томов, необходимых для вашего приложения. Это упрощает управление сложными настройками.

2. **Управление несколькими контейнерами**: вы можете запускать, останавливать и управлять несколькими контейнерами с помощью одной команды, что упрощает ваш рабочий процесс.

3. **Согласованность среды**: Docker Compose гарантирует, что ваше приложение будет работать в одной и той же среде в разных системах, что упрощает разработку, тестирование и развертывание.

4. **Зависимости служб**: Compose позволяет вам определять зависимости между службами, гарантируя, что они запускаются в правильном порядке.

5. **Масштабирование служб**: вы можете легко масштабировать службы вверх или вниз, указав количество экземпляров контейнеров в файле `docker-compose.yml`.

## Создание файла `docker-compose.yml`

Чтобы проиллюстрировать, как использовать Docker Compose, мы создадим простое многоконтейнерное приложение, состоящее из веб-сервера (использующего Flask) и базы данных Redis.

### Шаг 1: Создайте каталог проекта

1. Откройте терминал и создайте новый каталог для вашего проекта:

```bash
mkdir my-flask-app
cd my-flask-app
```

### Шаг 2: Создайте приложение Flask

2. Создайте файл с именем `app.py` со следующим содержимым:

```python
from flask import Flask
import redis

app = Flask(__name__)
redis_client = redis.StrictRedis(host='redis', port=6379, decode_responses=True)

@app.route('/')
def index():
visits = redis_client.incr('counter')
return f'Hello, World! You are visitor number {visits}.'

if __name__ == '__main__':
app.run(host='0.0.0.0')
```

### Шаг 3: Создайте `requirements.txt`

3. Создайте файл с именем `requirements.txt` со следующим содержимым:

```
Flask
redis
```

### Шаг 4: Создайте файл `docker-compose.yml`

4. В том же каталоге создайте файл с именем `docker-compose.yml` и добавьте следующее содержимое:

```yaml
version: '3.8'

services:
web:
build: .
ports:
- "5000:5000"
dependent_on:
- redis

redis:
image: "redis:alpine"
```

### Объяснение файла `docker-compose.yml`

- **version**: указывает версию формата файла Docker Compose.
- **services**: определяет различные службы, из которых состоит ваше приложение.
- **web**: служба веб-приложения Flask.
- **build**: указывает, что Docker должен построить образ из Dockerfile в текущем каталоге.
- **ports**: сопоставляет порт 5000 на хосте с портом 5000 в контейнере.
- **depends_on**: указывает, что служба `web` зависит от службы `redis`, гарантируя, что Redis запустится до веб-приложения.
- **redis**: служба Redis, использующая официальный образ Redis из Docker Hub.

### Шаг 5: Создайте Dockerfile

5. Создайте файл с именем `Dockerfile` в том же каталоге со следующим содержимым:

```dockerfile
# Используйте официальный образ Python из Docker Hub
FROM python:3.9-slim

# Установите рабочий каталог в контейнере
WORKDIR /app

# Скопируйте файл требований и установите зависимости
COPY requirements.txt requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Скопируйте код приложения в контейнер
COPY app.py app.py

# Команда для запуска приложения
CMD ["python", "app.py"]
```

## Запуск настройки нескольких контейнеров

### Шаг 1: Сборка и запуск служб

1. В терминале выполните следующую команду для сборки образов и запуска служб, определенных в файле `docker-compose.yml`:

```bash
docker compose up
```

Эта команда создаст образ веб-службы и запустит как веб-службу, так и службу Redis. Вы должны увидеть журналы, указывающие на то, что службы запущены.

### Шаг 2: Доступ к приложению

2. Откройте веб-браузер и перейдите по адресу `http://localhost:5000`. Вы должны увидеть сообщение с указанием количества посетителей:

```
Hello, World! Вы посетитель номер 1.
```

Обновите страницу, чтобы увидеть увеличение количества посетителей.

### Шаг 3: Остановка служб

3. Чтобы остановить службы, вы можете нажать `Ctrl + C` в терминале, где запущен Docker Compose. Или вы можете запустить:

```bash
docker compose down
```

Эта команда останавливает и удаляет контейнеры, определенные в файле `docker-compose.yml`.

## Заключение

В этом уроке вы узнали о Docker Compose и его преимуществах для управления многоконтейнерными приложениями. Вы создали файл `docker-compose.yml` для определения простого приложения Flask и базы данных Redis, а также запустили многоконтейнерную настройку с помощью одной команды. В следующем уроке мы рассмотрим расширенные функции Docker Compose, включая переменные среды и службы масштабирования.


## Лабораторная работа 3. Docker Compose для многоконтейнерных приложений

### Цель работы: освоить использование Docker Compose для управления многоконтейнерными приложениями.

### Задачи:
1. Создать файл `docker-compose.yml` для указанного многоконтейнерного приложения.
2. Запустить приложение с помощью `Docker Compose`.
3. Проверить работоспособность приложения и взаимодействие между контейнерами.
4. Выполнить индивидуальное задание.

### Критерии оценки:
- Правильность создания файла docker-compose.yml (4 балла).
- Корректность запуска приложения с помощью Docker Compose (3 балла).
- Работоспособность приложения и взаимодействие между контейнерами (2 балла).
- Выполнение индивидуального задания (1 балл).

### Ход работы (пример для Варианта 25):

1. Создание файла `docker-compose.yml` для приложения чата на `Node.js` и `Socket.IO`.
- Создайте новый каталог для проекта и перейдите в него:
  ```
  mkdir nodejs-chat-app
  cd nodejs-chat-app
  ```
- Создайте файл `app.js` со следующим содержимым:
  ```javascript
  const express = require('express');
  const http = require('http');
  const socketIO = require('socket.io');

  const app = express();
  const server = http.createServer(app);
  const io = socketIO(server);

  app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
  });

  io.on('connection', (socket) => {
    console.log('Новый пользователь подключился');

    socket.on('chat message', (msg) => {
      io.emit('chat message', msg);
    });

    socket.on('disconnect', () => {
      console.log('Пользователь отключился');
    });
  });

  server.listen(3000, () => {
    console.log('Сервер запущен на порту 3000');
  });
  ```
- Создайте файл `index.html` со следующим содержимым:
  ```html
  <!DOCTYPE html>
  <html>
  <head>
    <title>Чат на Socket.IO</title>
  </head>
  <body>
    <ul id="messages"></ul>
    <form id="chat-form">
      <input id="chat-input" autocomplete="off" /><button>Отправить</button>
    </form>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      const chatForm = document.getElementById('chat-form');
      const chatInput = document.getElementById('chat-input');
      const messages = document.getElementById('messages');

      chatForm.addEventListener('submit', (e) => {
        e.preventDefault();
        if (chatInput.value) {
          socket.emit('chat message', chatInput.value);
          chatInput.value = '';
        }
      });

      socket.on('chat message', (msg) => {
        const li = document.createElement('li');
        li.textContent = msg;
        messages.appendChild(li);
      });
    </script>
  </body>
  </html>
  ```
- Создайте файл `package.json` со следующим содержимым:
  ```json
  {
    "name": "nodejs-chat-app",
    "version": "1.0.0",
    "description": "Простой чат на Node.js и Socket.IO",
    "main": "app.js",
    "dependencies": {
      "express": "^4.17.1",
      "socket.io": "^4.1.2"
    }
  }
  ```
- Создайте файл `Dockerfile` со следующим содержимым:
  ```
  FROM node:14

  WORKDIR /app

  COPY package.json .
  RUN npm install

  COPY . .

  EXPOSE 3000

  CMD ["node", "app.js"]
  ```
- Создайте файл `docker-compose.yml` со следующим содержимым:
  ```yaml
  version: '3'
  services:
    web:
      build: .
      ports:
        - "3000:3000"
  ```

2. Запуск приложения с помощью `Docker Compose`.
- Находясь в каталоге проекта, выполните команду для запуска приложения:
  ```
  docker compose up
  ```

3. Проверка работоспособности приложения.
- Откройте веб-браузер и перейдите по адресу `http://localhost:3000`. Вы должны увидеть простой интерфейс чата.
- Откройте несколько вкладок браузера с тем же URL и отправьте сообщения из разных вкладок. Сообщения должны отображаться в режиме реального времени во всех вкладках.

4. Остановка приложения.
- Нажмите `Ctrl+C` в терминале, где запущено приложение, чтобы остановить контейнеры.

### Индивидуальные задания.

**Вариант 1.** Создайте `docker-compose.yml` для приложения на `Flask`, использующего базу данных `PostgreSQL` и `Redis` для кэширования.

**Вариант 2.** Создайте `docker-compose.yml` для приложения на `Django`, использующего базу данных `MySQL` и `Celery` для выполнения фоновых задач.

**Вариант 3.** Создайте `docker-compose.yml` для приложения на `Express.js`, использующего базу данных `MongoDB` и `Nginx` в качестве обратного прокси.

**Вариант 4.** Создайте `docker-compose.yml` для приложения на `Laravel`, использующего базу данных `PostgreSQL` и `Redis` для очереди задач.

**Вариант 5.** Создайте `docker-compose.yml` для приложения на `Ruby on Rails`, использующего базу данных `MySQL` и `Sidekiq` для обработки фоновых задач.

**Вариант 6.** Создайте `docker-compose.yml` для приложения на `Spring Boot`, использующего базу данных `PostgreSQL` и `RabbitMQ` для обмена сообщениями.

**Вариант 7.** Создайте `docker-compose.yml` для приложения на `ASP.NET Core`, использующего базу данных `SQL Server` и `Redis` для кэширования.

**Вариант 8.** Создайте `docker-compose.yml` для приложения на `Golang`, использующего базу данных `PostgreSQL` и `Kafka` для потоковой передачи данных.

**Вариант 9.** Создайте `docker-compose.yml` для приложения на `PHP`, использующего базу данных `MySQL`, `Apache` в качестве веб-сервера и `phpMyAdmin` для администрирования базы данных.

**Вариант 10.** Создайте `docker-compose.yml` для приложения на `Node.js`, использующего базу данных `MongoDB`, `Nginx` в качестве обратного прокси и MongoDB Express для администрирования базы данных.

**Вариант 11.** Создайте `docker-compose.yml` для приложения на `Flask`, использующего базу данных `SQLite` и `Gunicorn` в качестве сервера приложений.

**Вариант 12.** Создайте `docker-compose.yml` для приложения на `Django`, использующего базу данных `PostgreSQL` и `Nginx` для обслуживания статических файлов.

**Вариант 13.** Создайте `docker-compose.yml` для приложения на `Express.js`, использующего базу данных `MySQL` и `Redis` для сеансов.

**Вариант 14.** Создайте `docker-compose.yml` для приложения на Laravel, использующего базу данных MongoDB и Laravel Horizon для мониторинга очереди задач.

**Вариант 15.** Создайте `docker-compose.yml` для приложения на `Ruby on Rails`, использующего базу данных `PostgreSQL` и `Nginx` для обслуживания статических файлов.

**Вариант 16.** Создайте `docker-compose.yml` для приложения на `Spring Boot`, использующего базу данных `MySQL` и `Elasticsearch` для полнотекстового поиска.

**Вариант 17.** Создайте `docker-compose.yml` для приложения на `ASP.NET Core`, использующего базу данных `PostgreSQL` и `Seq` для ведения журналов.

**Вариант 18.** Создайте `docker-compose.yml` для приложения на `Golang`, использующего базу данных MongoDB и `Prometheus` для мониторинга.

**Вариант 19.** Создайте `docker-compose.yml` для приложения на `PHP`, использующего базу данных `PostgreSQL`, `Nginx` в качестве веб-сервера и `Adminer` для администрирования базы данных.

**Вариант 20.** Создайте `docker-compose.yml` для приложения на `Node.js`, использующего базу данных `Redis` и `Grafana` для визуализации данных.

**Вариант 21.** Создайте `docker-compose.yml` для приложения на `Flask`, использующего базу данных `MySQ`L и `Celery` для выполнения периодических задач.

**Вариант 22.** Создайте `docker-compose.yml` для приложения на `Django`, использующего базу данных `SQLite` и `Django Debug Toolbar` для отладки.

**Вариант 23.** Создайте `docker-compose.yml` для приложения на `Express.js`, использующего базу данных `PostgreSQL` и `pgAdmin` для администрирования базы данных.

**Вариант 24.** Создайте `docker-compose.yml` для приложения на `Laravel`, использующего базу данных `MySQL` и `Laravel Echo Server` для обработки событий в реальном времени.

**Вариант 25.** Создайте `docker-compose.yml` для приложения на `Ruby on Rails`, использующего базу данных MongoDB и `Sidekiq Web` для мониторинга фоновых задач.

### Форма отчета:
1. Титульный лист.
2. Цель работы.
3. Ход выполнения работы (с указанием используемых команд и их результатов).
4. Листинг созданного файла `docker-compose.yml`.
5. Выводы по работе.
6. Ответы на контрольные вопросы.

### Контрольные вопросы:
1. Что такое `Docker Compose` и для чего он используется?
2. Какие основные преимущества использования `Docker Compose` для управления многоконтейнерными приложениями?
3. Какие основные разделы и директивы используются в файле `docker-compose.yml`?
4. Как запустить многоконтейнерное приложение с помощью `Docker Compose`?
5. Как остановить и удалить контейнеры, запущенные с помощью `Docker Compose`?
